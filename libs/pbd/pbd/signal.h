
/** THIS FILE IS AUTOGENERATED: DO NOT EDIT.
 *
 *  This file is generated by signals.h.py.
 */

#include <list>
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/enable_shared_from_this.hpp>
#include <boost/optional.hpp>
#include "pbd/stacktrace.h"

namespace PBD {

class Connection;

class SignalBase : public boost::enable_shared_from_this<SignalBase>
{
public:
	virtual ~SignalBase () {}
	virtual void disconnect (boost::shared_ptr<Connection>) = 0;

protected:
	boost::mutex _mutex;
};

class Connection : public boost::enable_shared_from_this<Connection>
{
public:
	Connection (boost::shared_ptr<SignalBase> b) : _signal (b) {}

	void disconnect ()
	{
		if (_signal) {
			_signal->disconnect (shared_from_this ());
		} 
	}

private:
	boost::shared_ptr<SignalBase> _signal;
};

template<typename R>
class OptionalLastValue
{
public:
	typedef boost::optional<R> result_type;

	template <typename Iter>
	result_type operator() (Iter first, Iter last) const {
		result_type r;
		while (first != last) {
			r = *first;
			++first;
		}

		return r;
	}
};

template <typename R, typename C = OptionalLastValue<R> >
class SimpleSignal0 : public SignalBase
{
public:

	typedef boost::function<R()> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit ()
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)());
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal0<R, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal0<R, C> > (new SimpleSignal0<R, C>);
	}

private:

	friend class Connection;

	SimpleSignal0 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <>
class SimpleSignal0<void> : public SignalBase
{
public:

	typedef boost::function<void()> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit ()
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}

#if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ >= 6))                                                                      
                for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {                                                 
#else                                                                                                                             
                for (Slots::iterator i = s.begin(); i != s.end(); ++i) {                                                          
#endif                                                                                                                               


			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)();
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal0<void> > create ()
	{
		return boost::shared_ptr<SimpleSignal0<void> > (new SimpleSignal0<void>);
	}

private:

	friend class Connection;

	SimpleSignal0 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename R, typename A1, typename C = OptionalLastValue<R> >
class SimpleSignal1 : public SignalBase
{
public:

	typedef boost::function<R(A1)> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit (A1 a1)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)(a1));
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal1<R, A1, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal1<R, A1, C> > (new SimpleSignal1<R, A1, C>);
	}

private:

	friend class Connection;

	SimpleSignal1 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename A1>
class SimpleSignal1<void, A1> : public SignalBase
{
public:

	typedef boost::function<void(A1)> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit (A1 a1)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)(a1);
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal1<void, A1> > create ()
	{
		return boost::shared_ptr<SimpleSignal1<void, A1> > (new SimpleSignal1<void, A1>);
	}

private:

	friend class Connection;

	SimpleSignal1 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename R, typename A1, typename A2, typename C = OptionalLastValue<R> >
class SimpleSignal2 : public SignalBase
{
public:

	typedef boost::function<R(A1, A2)> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit (A1 a1, A2 a2)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)(a1, a2));
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal2<R, A1, A2, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal2<R, A1, A2, C> > (new SimpleSignal2<R, A1, A2, C>);
	}

private:

	friend class Connection;

	SimpleSignal2 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename A1, typename A2>
class SimpleSignal2<void, A1, A2> : public SignalBase
{
public:

	typedef boost::function<void(A1, A2)> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit (A1 a1, A2 a2)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)(a1, a2);
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal2<void, A1, A2> > create ()
	{
		return boost::shared_ptr<SimpleSignal2<void, A1, A2> > (new SimpleSignal2<void, A1, A2>);
	}

private:

	friend class Connection;

	SimpleSignal2 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename R, typename A1, typename A2, typename A3, typename C = OptionalLastValue<R> >
class SimpleSignal3 : public SignalBase
{
public:

	typedef boost::function<R(A1, A2, A3)> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit (A1 a1, A2 a2, A3 a3)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)(a1, a2, a3));
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal3<R, A1, A2, A3, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal3<R, A1, A2, A3, C> > (new SimpleSignal3<R, A1, A2, A3, C>);
	}

private:

	friend class Connection;

	SimpleSignal3 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename A1, typename A2, typename A3>
class SimpleSignal3<void, A1, A2, A3> : public SignalBase
{
public:

	typedef boost::function<void(A1, A2, A3)> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit (A1 a1, A2 a2, A3 a3)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)(a1, a2, a3);
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal3<void, A1, A2, A3> > create ()
	{
		return boost::shared_ptr<SimpleSignal3<void, A1, A2, A3> > (new SimpleSignal3<void, A1, A2, A3>);
	}

private:

	friend class Connection;

	SimpleSignal3 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename R, typename A1, typename A2, typename A3, typename A4, typename C = OptionalLastValue<R> >
class SimpleSignal4 : public SignalBase
{
public:

	typedef boost::function<R(A1, A2, A3, A4)> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit (A1 a1, A2 a2, A3 a3, A4 a4)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)(a1, a2, a3, a4));
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal4<R, A1, A2, A3, A4, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal4<R, A1, A2, A3, A4, C> > (new SimpleSignal4<R, A1, A2, A3, A4, C>);
	}

private:

	friend class Connection;

	SimpleSignal4 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename A1, typename A2, typename A3, typename A4>
class SimpleSignal4<void, A1, A2, A3, A4> : public SignalBase
{
public:

	typedef boost::function<void(A1, A2, A3, A4)> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit (A1 a1, A2 a2, A3 a3, A4 a4)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)(a1, a2, a3, a4);
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal4<void, A1, A2, A3, A4> > create ()
	{
		return boost::shared_ptr<SimpleSignal4<void, A1, A2, A3, A4> > (new SimpleSignal4<void, A1, A2, A3, A4>);
	}

private:

	friend class Connection;

	SimpleSignal4 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename R, typename A1, typename A2, typename A3, typename A4, typename A5, typename C = OptionalLastValue<R> >
class SimpleSignal5 : public SignalBase
{
public:

	typedef boost::function<R(A1, A2, A3, A4, A5)> slot_function_type;
	typedef boost::optional<R> result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	typename C::result_type emit (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		std::list<R> r;
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				r.push_back ((i->second)(a1, a2, a3, a4, a5));
			}
		}
		C c;
		return c (r.begin(), r.end());
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal5<R, A1, A2, A3, A4, A5, C> > create ()
	{
		return boost::shared_ptr<SimpleSignal5<R, A1, A2, A3, A4, A5, C> > (new SimpleSignal5<R, A1, A2, A3, A4, A5, C>);
	}

private:

	friend class Connection;

	SimpleSignal5 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

template <typename A1, typename A2, typename A3, typename A4, typename A5>
class SimpleSignal5<void, A1, A2, A3, A4, A5> : public SignalBase
{
public:

	typedef boost::function<void(A1, A2, A3, A4, A5)> slot_function_type;
	typedef void result_type;
private:


	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;

public:


	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}

	void emit (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		Slots s;
		{
			boost::mutex::scoped_lock lm (_mutex);
			s = _slots;
		}
		for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {

			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {
				(i->second)(a1, a2, a3, a4, a5);
			}
		}
	}

	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}

	static boost::shared_ptr<SimpleSignal5<void, A1, A2, A3, A4, A5> > create ()
	{
		return boost::shared_ptr<SimpleSignal5<void, A1, A2, A3, A4, A5> > (new SimpleSignal5<void, A1, A2, A3, A4, A5>);
	}

private:

	friend class Connection;

	SimpleSignal5 () {}

	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    

}
